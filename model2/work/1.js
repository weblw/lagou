// 一、执行结果和说明
var a = []
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]()
// 执行结果 10
// 因为i是全局变量，for循环完成的时候i的值为10

// 二、执行结果和说明
var temp = 123
if (true) {
  console.log(temp)
  let temp
}
// 返回结果 报错  Cannot access 'temp' before initialization
// 因为let声明的是块级作用域变量，并且不存在变量提升

// 三、找数组中最小值
var arr = [12, 34, 32, 89, 4]
console.log(arr.sort((a, b) => a - b).shift())

// 四、变量声明差别

// var存在变量提升，不能声明块级作用域变量
// let、const不存在变量提升，能够声明块级作用域变量
// const声明的变量是常量

// 五、输出结果和为什么
var a = 10
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
// 输出结果 20
// fn是被obj调用的，它里面的this指向obj
// setTimeOut的回调函数使用箭头函数，它里面的this指向包裹它的普通函数中的this，也就是fn中的this
// 所以this.a就是obj.a，输出结果20

// 六、Symbol类型的用途

// 可用于声明不重复的变量key值

// 七、深、浅拷贝

// 浅拷贝：只复制对象或者数组的第一层  
// 深拷贝：把对象或者数组的所有嵌套内容完全复制

// 八、TypeScript和JavaScript关系

// TypeScript是JavaScript的超级，包含所有JS的内容以及ES6新特性，并且有类型前类型语言的类型约束

// 九、TypeScript优缺点

// 优点：类型约束，更有利于大型应用开发、团队合作；代码更安全；代码阅读更友好
// 缺点：学习成本，需要花时间去写类型约束和类型声明

// 十、引用计数原理、优缺点

// 引用计数：通过标记变量的引用次数，来实现垃圾回收
// 优点：简单
// 缺点：变量存在循环引用时，引用计数算法失效

// 十一、标记整理工作流程

// 标记整理：程序首次进入，标记可达对象，再次循环时将可达对象移动到一起，清除不可达对象

// 十二、V8新生代、老生代垃圾回收

// 待补充

// 十三、增量标记

// 增量标记：是程序运行的间歇阶段分批次对变量进行标记，首次先标记从根变量能够直接可达的第一层对象，之后在逐渐一层层深入标记
// 标记完所有可达对象之后进行垃圾清除